[{"id":"1711473114485","desc":"imp1 1","value":"extern crate rand;\r\nextern crate nalgebra;\r\n\r\n\r\nmod ball {\r\n    use nalgebra::Vector2;\r\n    // use rand::Rng;\r\n    \r\n    pub struct Ball {\r\n        pub position: Vector2<f64>,\r\n        pub lposition:nalgebra::Vector2<f64>,\r\n        pub color: (u8, u8, u8),\r\n        pub radius: f64,\r\n \r\n        // pub path: Vec<[i64; 2]>,\r\n    }\r\n\r\n    impl Ball {\r\n        pub fn new(x: f64, y: f64, velocity:Vector2<f64>) -> Ball {\r\n            Ball {\r\n                position: Vector2::new(x, y),\r\n                lposition: Vector2::new(x, y)-velocity,\r\n                radius: 10.0,\r\n                color :(255,255,255),\r\n                // path: Vec::new(),\r\n                // color: (rand::thread_rng().gen_range(0..255),\r\n                //         rand::thread_rng().gen_range(0..255),\r\n                //         rand::thread_rng().gen_range(0..255)),\r\n            }\r\n        }\r\n\r\n        pub fn update(&mut self,) {\r\n            // self.path.push([self.position[0] as i64, self.position[1] as i64]);\r\n            // if self.path.len() > 500 {\r\n            //     self.path.remove(0);\r\n            // }\r\n                self.position += self.position-self.lposition;\r\n        }\r\n\r\n\r\n\r\n        pub fn collide(&mut self, other: &mut Ball) {\r\n            let dist: f64= (other.position - self.position).norm();\r\n            if dist < self.radius+other.radius {\r\n                let collision_normal:Vector2<f64> = self.position-other.position;\r\n                self.position -= collision_normal * (self.radius+other.radius-dist) * (0.5);\r\n                self.position += collision_normal * (self.radius+other.radius-dist) * (0.5);\r\n                                    \r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n\r\nmod ball_set {\r\n    use crate::balls::ball::Ball;\r\n\r\n    pub struct BallSet {\r\n        pub balls: Vec<Ball>,\r\n        pub ke: f64,\r\n        pub grid_size: f64,\r\n        pub grid_dim: (usize, usize),\r\n    }\r\n\r\n    impl BallSet {\r\n        pub fn new(balls: Vec<Ball>) -> BallSet {\r\n            BallSet {\r\n                balls,\r\n                ke: 0.0,\r\n                grid_size: 80.0,\r\n                grid_dim: (16, 9),\r\n            }\r\n        }\r\n\r\n        pub fn update(&mut self) {\r\n            let grid:[[u32;self.grid_dim[0]];self.grid_dim[1]];\r\n            for (ind, i) in self.balls.iter().enumerate() {\r\n                i.update();\r\n                grid[(f64::floor(f64::max(0.0, f64::min(i.position[0] / self.grid_size, self.grid_dim.0 as f64 - 1.0)))\r\n    + f64::max(0.0, f64::min(i.position[1] / self.grid_size, self.grid_dim.1 as f64 - 1.0)) * self.grid_dim.0 as f64)\r\n    as usize].push(ind);\r\n            for i in 0..((self.grid_dim.0)*self.grid_dim.1){\r\n                for &j in &[0, 1, -1, self.grid_dim.0 as isize, (-1 * self.grid_dim.0 as isize), (1 + self.grid_dim.0 as isize), (-1 + self.grid_dim.0 as isize), (1 - self.grid_dim.0 as isize), (-1 - self.grid_dim.0 as isize)] {\r\n                    if let Some(index) = (i as isize + j).try_into().ok() {\r\n                        if index >= 0 && index < 144 {\r\n                            self.cocell(grid[i], grid[index]);\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                \r\n            }\r\n\r\n            }\r\n            \r\n        \r\n        }\r\n        \r\n        pub fn cocell(&mut self,cell1,cell2){\r\n            \r\n        }\r\n\r\n        pub fn interact(&mut self, p: u32) {\r\n            // Interaction logic (not implemented here)\r\n        }\r\n    }\r\n}\r\n\r\n","position":{"line":98,"character":43}}]