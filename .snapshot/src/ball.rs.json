[{"id":"1711807245303","desc":"square stable","value":"\r\nextern crate rand;\r\nextern crate nalgebra;\r\nuse std::cmp::{max, min};\r\n\r\n\r\npub mod ball {\r\n    use nalgebra::Vector2;\r\n    \r\n    // use rand::Rng;\r\n    use sdl2::pixels::Color;\r\n    use sdl2::rect::Rect;\r\n    use sdl2::render::WindowCanvas;\r\n    pub struct Ball {\r\n        pub position: Vector2<f64>,\r\n        pub lposition:nalgebra::Vector2<f64>,\r\n        pub color: (u8, u8, u8),\r\n        pub radius: f64,\r\n \r\n        // pub path: Vec<[i64; 2]>,\r\n    }\r\n\r\n    impl Ball {\r\n        pub fn new(x: f64, y: f64, velocity:Vector2<f64>) -> Ball {\r\n            Ball {\r\n                position: Vector2::new(x, y),\r\n                lposition: Vector2::new(x, y)-velocity,\r\n                radius: 10.0,\r\n                color :(255,255,255),\r\n                // path: Vec::new(),\r\n                // color: (rand::thread_rng().gen_range(0..255),\r\n                //         rand::thread_rng().gen_range(0..255),\r\n                //         rand::thread_rng().gen_range(0..255)),\r\n            }\r\n        }\r\n\r\n        pub fn update(&mut self,) {\r\n            // self.path.push([self.position[0] as i64, self.position[1] as i64]);\r\n            // if self.path.len() > 500 {\r\n            //     self.path.remove(0);\r\n            // }\r\n                let temp = self.position;\r\n                self.position += self.position-self.lposition;\r\n                self.lposition = temp;\r\n        }   \r\n\r\n\r\n\r\n        pub fn collide(&mut self, other: &mut Ball) {\r\n            let dist: f64= (other.position - self.position).norm();\r\n            if dist < self.radius+other.radius {\r\n                let collision_normal:Vector2<f64> = self.position-other.position;\r\n                self.position -= collision_normal * (self.radius+other.radius-dist) * (0.5);\r\n                self.position += collision_normal * (self.radius+other.radius-dist) * (0.5);\r\n                                    \r\n            }\r\n        }\r\n        pub fn draw(&self, canvas: &mut WindowCanvas) {\r\n            canvas.set_draw_color(Color::RGB(self.color.0, self.color.1, self.color.2));\r\n            let center = self.position.map(|x| x as i32);\r\n            let radius = self.radius as i32;\r\n            let rect = Rect::new(center.x - radius, center.y - radius,( radius * 2 )as u32,( radius * 2 )as u32);\r\n            canvas.fill_rect(rect).expect(\"Failed to draw ball\");\r\n        }\r\n\r\n    }\r\n}\r\nfn get_two_elements<T>(vec: &mut Vec<T>, first: usize, second: usize) -> (&mut T, &mut T) {\r\n    let s = max(first, second);\r\n    let f = min(first, second);\r\n    assert!(second < vec.len());\r\n    if let [f, .., s] = &mut vec[f..=s] {\r\n        (f, s)\r\n    } else {\r\n        unreachable!()\r\n    }\r\n}\r\n\r\npub mod ball_set {\r\n    use crate::ball::ball::Ball;\r\n\r\n    use nalgebra::Normed;\r\n    use sdl2::render::WindowCanvas;\r\n    pub struct BallSet {\r\n        pub balls: Vec<Ball>,\r\n        pub ke: f64,\r\n        pub grid_size: f64,\r\n        pub grid_dim: (usize, usize),\r\n    }\r\n\r\n    impl BallSet {\r\n        pub fn new(balls: Vec<Ball>) -> BallSet {\r\n            BallSet {\r\n                balls,\r\n                ke: 0.0,\r\n                grid_size: 80.0,\r\n                grid_dim: (16, 9),\r\n            }\r\n        }\r\n\r\n        pub fn update(&mut self) {\r\n            let mut grid: Vec<Vec<usize>> = vec![] ;\r\n            for _i in 0..self.grid_dim.0 * self.grid_dim.1{\r\n                grid.push(vec![])\r\n            }\r\n\r\n            for (ind, ball) in self.balls.iter_mut().enumerate() {\r\n                ball.update();\r\n                self.ke+=(ball.position-ball.lposition).norm_squared();\r\n            use std::cmp::{max, min};\r\n            let x = max(min((ball.position.x / self.grid_size) as usize, self.grid_dim.0 - 1), 0);\r\n            let y = max(min((ball.position.y / self.grid_size) as usize, self.grid_dim.1 - 1), 0);\r\n            let index = x + y * self.grid_dim.0;\r\n            grid[index].push(ind);\r\n            \r\n            }\r\n            \r\n            for i in 0..self.grid_dim.0*self.grid_dim.1{\r\n                for x in -1..2{\r\n                    for y in -1..2{\r\n                        let r = (self.grid_dim.0 as i32 )*x+y+i as i32;\r\n                        if r>=0 && r<(self.grid_dim.0*self.grid_dim.1) as i32{\r\n                                for e1 in &grid[i]{\r\n                                    for e2 in &grid[r as usize]{   {\r\n                                        if e1==e2{continue;};\r\n                                        let (b1, b2) = crate::ball::get_two_elements(&mut self.balls, *e1, *e2);\r\n                                        b1.collide(b2);\r\n                                    }\r\n                            }\r\n                        }\r\n                    } \r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n    fn interact(&mut self){\r\n\r\n    }\r\n    pub fn draw(&mut self,canvas:&mut WindowCanvas){\r\n        for ball in &self.balls {\r\n            ball.draw(canvas);\r\n\r\n        }\r\n        println!( \"{}\",self.ke );\r\n        self.ke =0.0;\r\n    }\r\n}\r\n\r\n}","position":{"line":47,"character":0}}]